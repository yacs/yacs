<?php
/**
 * handle user presence in the background
 *
 * This script is a AJAX back-end, that can jointly receive and process new
 * notifications, or transmit live notifications to present surfers.
 *
 * @see shared/yacs.js
 *
 * The minimum period of time to call this script should be some seconds,
 * because of potential network latency.
 *
 * The maximum period of time between calls should be 120 seconds,
 * since notifications die after 180 seconds anyway.
 *
 * Notifications are described in [script]users/notifications.php[/script], and
 * the AJAX front-end has been implemented in shared/yacs.js
 *
 * This script is also used to refresh session data. This is an effective way
 * to preserve idle sessions at some rough ISP.
 *
 * Accept following invocations:
 * - heartbit.php
 *
 * @author Bernard Paques
 * @reference
 * @license http://www.gnu.org/copyleft/lesser.txt GNU Lesser General Public License
 */

// common definitions and initial processing
include_once '../shared/global.php';
include_once 'notifications.php';

// ensure browser always look for fresh data
http::expire(0);

// surfer has to be logged --provide a short response
if(!Surfer::get_id()) {
	Safe::header('Status: 401 Unauthorized', TRUE, 401);
	die(i18n::s('You are not allowed to perform this operation.'));

// a new notification has been submitted
} elseif(isset($_REQUEST['recipient']) && isset($_REQUEST['type'])) {

	// record the notification
	$fields = array();
	$fields['nick_name'] = Surfer::get_name();
	$fields['recipient'] = $_REQUEST['recipient'];
	$fields['type'] = $_REQUEST['type'];

	if(isset($_REQUEST['address']))
		$fields['address'] = encode_link($_REQUEST['address']);
	if(isset($_REQUEST['message']))
		$fields['message'] = strip_tags($_REQUEST['message']);

	// vaidate notification attributes
	switch($fields['type']) {

	case 'browse':
		if(!isset($_REQUEST['address'])) {
			Safe::header('Status: 400 Bad Request', TRUE, 400);
			die(i18n::s('Request is invalid.'));
		}
		break;

	case 'hello':
		if(!isset($_REQUEST['message'])) {
			Safe::header('Status: 400 Bad Request', TRUE, 400);
			die(i18n::s('Request is invalid.'));
		}
		break;

	default:
		Safe::header('Status: 400 Bad Request', TRUE, 400);
		die(i18n::s('Request is invalid.'));

	}

	// save in the database
	Notifications::post($fields);

	// thread update will trigger screen repaint through separate pending call of this script
	die('OK');

// look for some notification
} elseif(isset($_SERVER['REQUEST_METHOD']) && ($_SERVER['REQUEST_METHOD'] != 'HEAD')) {

	// change session data to extend life of related file
	if(!isset($_SESSION['heartbit']))
		$_SESSION['heartbit'] = 0;
	$_SESSION['heartbit']++;

	// refresh the watchdog
	$_SESSION['watchdog'] = time();

	// update surfer presence
	$query = "UPDATE ".SQL::table_name('users')
		." SET click_date='".gmstrftime('%Y-%m-%d %H:%M:%S')."'"
		." WHERE (id = ".SQL::escape(Surfer::get_id()).")";
	SQL::query($query, FALSE, $context['users_connection']);

	// assign article for more time
	if(isset($_REQUEST['action']) && ($_REQUEST['action'] == 'edit')
		&& isset($_REQUEST['reference']) && !strncmp($_REQUEST['reference'], 'article:', 8)) {

		// refresh record of this article
		$query = "UPDATE ".SQL::table_name('articles')." SET "
			." assign_date = '".SQL::escape(gmstrftime('%Y-%m-%d %H:%M:%S'))."'"
			." WHERE (id = ".SQL::escape(substr($_REQUEST['reference'],8)).") AND (assign_id = ".SQL::escape(Surfer::get_id()).")";
		SQL::query($query);

	}

	// look for one notification -- script will be be killed if none is available
	$response = Notifications::pull();

	// encode result in JSON
	$output = Safe::json_encode($response);

	// allow for data compression
	render_raw('application/json; charset='.$context['charset']);

	// actual transmission except on a HEAD request
	if(isset($_SERVER['REQUEST_METHOD']) && ($_SERVER['REQUEST_METHOD'] != 'HEAD'))
		echo $output;

	// the post-processing hook, then exit
	finalize_page(TRUE);

}

?>
